(function(){
  // COPY of lib/ui/replyDeck.js (Stage-2). See DEPRECATION note on old path.
  const deckState = new WeakMap();
  const REDUCED = typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const METRICS = new URLSearchParams(location.search).get('metrics') === '1';
  function parseSections(md){ if(!md||typeof md!=='string') return [{title:'Response',body:''}]; const lines=md.replace(/\r\n?/g,'\n').split('\n'); const out=[]; let cur=null; for(const line of lines){ const m=line.match(/^\s*###\s*(.+?)\s*$/); if(m){ if(cur) out.push(cur); cur={title:m[1].trim(), body:''}; } else { if(!cur) cur={title:'Response', body:''}; cur.body+=(cur.body?'\n':'')+line; } } if(cur) out.push(cur); return out.filter(s=>s.title||s.body); }
  function htmlEscape(s){ return String(s).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
  function sectionToHtml(sec){ const body=htmlEscape(sec.body).replace(/\n/g,'<br>'); return `<article class="deck-slide" role="group" aria-label="${htmlEscape(sec.title)}"><h3 class="deck-title">${htmlEscape(sec.title)}</h3><div class="deck-body gemini-output">${body}</div></article>`; }
  function metricsLog(...a){ if(METRICS) console.info('[metrics]',...a); }
  function destroy(containerEl){ const st=deckState.get(containerEl); if(!st) return; try{ st.arrows?.forEach(btn=>btn.removeEventListener('click', st.handlers.onArrow)); st.dots?.forEach(btn=>btn.removeEventListener('click', st.handlers.onDot)); if(st.rail){ st.rail.removeEventListener('keydown', st.handlers.onKey); st.rail.removeEventListener('touchstart', st.handlers.onTouchStart); st.rail.removeEventListener('touchmove', st.handlers.onTouchMove, st.handlers.touchMoveOpts); st.rail.removeEventListener('touchend', st.handlers.onTouchEnd); st.rail.removeEventListener('touchcancel', st.handlers.onTouchEnd);} st.ro?.disconnect(); if(st.timers) st.timers.forEach(t=>clearTimeout(t)); }catch{} deckState.delete(containerEl); const root=containerEl.querySelector(':scope > .reply-deck'); if(root&&root.parentNode===containerEl) containerEl.removeChild(root); }
  function render(containerEl, markdown, { asOf }={}){ destroy(containerEl); const sections=parseSections(markdown); const reduced=REDUCED; const id='deck-'+Math.random().toString(36).slice(2,8); const dots=sections.map((_,i)=>`<button class="deck-dot" type="button" aria-label="Go to slide ${i+1} of ${sections.length}" data-idx="${i}"></button>`).join(''); const slides=sections.map((s,i)=>`<div class="deck-snap" id="${id}-slide-${i}" aria-roledescription="slide" aria-label="${htmlEscape(s.title)}">${sectionToHtml(s)}</div>`).join(''); const footer=asOf?`<div class="deck-footer" aria-live="polite">as of ${htmlEscape(asOf)}</div>`:''; const rootHtml=`<div class="reply-deck" role="region" aria-roledescription="carousel" aria-label="AI Bradaa response"><div class="deck-rail" tabindex="0">${slides}</div><div class="deck-dots" role="tablist">${dots}</div><button class="deck-arrow left" aria-label="Previous slide" type="button">◄</button><button class="deck-arrow right" aria-label="Next slide" type="button">►</button>${footer}</div>`; containerEl.insertAdjacentHTML('beforeend', rootHtml); const root=containerEl.querySelector(':scope > .reply-deck'); const rail=root.querySelector('.deck-rail'); const arrowL=root.querySelector('.deck-arrow.left'); const arrowR=root.querySelector('.deck-arrow.right'); const dotEls=Array.from(root.querySelectorAll('.deck-dot')); let index=0; function scrollToIndex(i, smooth=!reduced){ index=Math.max(0, Math.min(sections.length-1, i)); const target=root.querySelector(`#${id}-slide-${index}`); if(target) target.scrollIntoView({ behavior: smooth?'smooth':'auto', inline:'start', block:'nearest' }); dotEls.forEach((d,di)=>{ d.toggleAttribute('aria-current', di===index); d.classList.toggle('active', di===index); }); }
    const handlers={ onArrow:(e)=>{ const dir=e.currentTarget.classList.contains('left')?-1:1; scrollToIndex(index+dir); }, onDot:(e)=>{ const di=Number(e.currentTarget.dataset.idx||0); scrollToIndex(di); }, onKey:(e)=>{ if(e.key==='ArrowLeft'){ scrollToIndex(index-1);} else if(e.key==='ArrowRight'){ scrollToIndex(index+1);} } };
    arrowL.addEventListener('click', handlers.onArrow); arrowR.addEventListener('click', handlers.onArrow); dotEls.forEach(d=>d.addEventListener('click', handlers.onDot)); rail.addEventListener('keydown', handlers.onKey);
    let touch=null; const touchMoveOpts={ passive:false }; const onTouchStart=(e)=>{ const t=e.changedTouches[0]; touch={x:t.clientX,y:t.clientY}; }; const onTouchMove=(e)=>{ if(!touch) return; const t=e.changedTouches[0]; const dx=t.clientX-touch.x; const dy=t.clientY-touch.y; if(Math.abs(dx)>Math.abs(dy)&&Math.abs(dx)>12){ e.preventDefault(); } }; const onTouchEnd=(e)=>{ if(!touch) return; const t=e.changedTouches[0]; const dx=t.clientX-touch.x; const dy=t.clientY-touch.y; touch=null; if(Math.abs(dx)>Math.abs(dy)&&Math.abs(dx)>40){ if(dx<0) scrollToIndex(index+1); else scrollToIndex(index-1); } }; rail.addEventListener('touchstart', onTouchStart); rail.addEventListener('touchmove', onTouchMove, touchMoveOpts); rail.addEventListener('touchend', onTouchEnd); rail.addEventListener('touchcancel', onTouchEnd);
    const ro=(typeof ResizeObserver!=='undefined')? new ResizeObserver(()=>scrollToIndex(index,false)) : null; if(ro) ro.observe(rail);
    scrollToIndex(0,false); metricsLog('deckSlides', sections.length);
    const timers=[]; deckState.set(containerEl,{ root, rail, arrows:[arrowL,arrowR], dots:dotEls, handlers:{...handlers, onTouchStart, onTouchMove, onTouchEnd, touchMoveOpts}, timers, ro });
    return { count: sections.length, destroy: ()=>destroy(containerEl) };
  }
  const api={ render, destroy }; if(typeof module!=='undefined'&&module.exports) module.exports=api; if(typeof window!=='undefined') window.ReplyDeck=api;
})();
